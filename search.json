[{"title":"23-9-9-模拟赛题解","url":"/2023/09/13/23-9-9-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"Drop everything now,Meet me in the pouring rain.Kiss me on the sidewalk,Take away the pain.\n\ngogogobky\nT1. SYOJ #1007 / Luogu P3199\n环形跑【大体思路】　　二分 + 0/1 分数规划 + Spfa（DFS优化判负环）\n【详解】　　有一说一，其实不知道 0/1 分数规划是啥也能做。正向考虑找边权平均值最小的环非常困难，所以我们不妨从结果入手反推找有没有符合要求的环。这样二分的思路就明确了，然后就突然想到之前做过一道关于平均值的二分题，这里搬个当时写的题解看看。\n\n　　我们把环上的每个元素都减去二分出的平均值，在这个基础上跑最短路找环。因为要找的是平均值最小的环，正好与上面这道题相反，如果找到了负环就说明有比二分出的平均值符合要求且存在更优的答案，可以再接着缩小二分范围。\n　　这里的 Spfa 使用递归写法，求负环比较方便。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 5e3 + 5;const int M = 1e5 + 5;const double inf = 1e9;const double eps = 1e-10;int n, m;int head[N], edge[M], nxt[M], w[M], tot;double l = -inf, r = inf, vis[N], f, dist[N];void add(int x, int y, double z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void check(int x, double d) {    vis[x] = 1;    for (int i = head[x]; i; i = nxt[i]) {        int y = edge[i];        double z = w[i];        if (dist[y] &gt; dist[x] + z - d) {            if (vis[y] || f) {                f = 1;                break;            }            dist[y] = dist[x] + z - d;            check(y, d);        }    }    vis[x] = 0;    return ;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++) {        int a, b;        double c;        scanf(\"%d%d%lf\", &amp;a, &amp;b, &amp;c);        add(a, b, c);    }    while (r - l &gt; eps) {        memset(dist, 0, sizeof(dist));        memset(vis, 0, sizeof(vis));        f = 0;        double mid = (l + r) / 2;        for (int i = 1; i &lt;= n; i++) {            check(i, mid);            if (f) {                break;            }        }        if (f) {            r = mid;        } else {            l = mid;        }    }    if (r == inf) {        printf(\"No solution\");    } else {        printf(\"%.8lf\", l);    }    return 0;}\n\nT2. SYOJ #1019 / Luogu P5764 \n奶牛串门 / 新年好【大体思路】　　枚举 + 最短路（Dijkstra）\n【详解】　　我们不知道以一个怎样的顺序可以使走出的距离最短，但是知道一共只有五个点，把这所有的可能性都枚举一遍也只有  种情况，还是很能接受的。\n　　事实上，在看到这道题的时候第一想法是分层图，把点建五层，从最下面一层开始，每走到一个新的目标点就升一层，最终在第五层统计答案。在写的时候遇到了一个困难，就是可能会在一个环上一直重复走爬层，虽然是走到了足够多的目标点，但是是重复计数的。给目标点原来的编号打标记是不行的，只能硬判断是不是走到了没走过的目标点，以及还需要考虑目标点是可以重复到达的，但是不会计数。略微有亿点点麻烦。感觉这个做法理论上是可以的，但是不知道哪里写挂了，死活调不对，于是遗憾离场。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int inf = 0x3fffffff;const int N = 5e4 + 5;const int M = 1e6 + 10;int n, m, ans = inf, dist[6][N], t[6];int head[N], edge[M], nxt[M], w[M], tot;int b[6] = {1, 2, 3, 4, 5};bool vis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void add(int x, int y, int z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void dij(int k) {    memset(vis, 0, sizeof(vis));    dist[k][t[k]] = 0;    q.push(make_pair(0, t[k]));    while (!q.empty( )) {        int x = q.top().second;        q.pop();        if (vis[x]) {            continue;        }        vis[x] = 1;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (vis[y]) {                continue;            }            dist[k][y] = min(dist[k][y], dist[k][x] + z);            q.push(make_pair(-dist[k][y], y));        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= 5; i++) {        scanf(\"%d\", &amp;t[i]);    }    t[0] = 1;    for (int i = 1; i &lt;= m; i++) {        int x, y, z;        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);        add(x, y, z);        add(y, x, z);    }    memset(dist, 0x3f, sizeof(dist));    for (int i = 0; i &lt;= 5; i++) {        dij(i);    }    ans = inf;    do {        int res = dist[0][t[b[0]]];        for (int j = 0; j &lt;= 3; j++) {            res += dist[b[j]][t[b[j + 1]]];        }        ans = min(ans, res);    } while (next_permutation(b, b + 5));    printf(\"%d\", ans);    return 0;}\n\nT3. SYOJ #1020 / Luogu P1938 / [USACO09NOV] \n阿龙打工 / Job Hunt S【大体思路】　　Spfa判负环\n【详解】　　比赛开始30分钟静坐灵光乍现产物。\n　　是看到可以无限赚钱的特判联想到了负环的性质，噶的一下就想建个负权边直接跑 Spfa，怒打码一测就发现好像还真有点意思。更有意思的是，当时根本没看见数据范围小小的很可爱适合 Floyd，然后在码里敲了下面这段：\n//啊？咋没记得第一次看的时候数据范围可以跑 Floyd ，所以用了 Spfa\n//等我写个对拍看看\n　　实际上 Floyd 根本没打。\n　　Spfa 跑的还是略快一点的。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int N = 5e3 + 5;const int M = 1e5 + 5;int n, m, l, k, s;int head[N], edge[M * 2], nxt[M * 2], tot, cnt[N];bool vis[N],flag;ll w[M * 2], dist[N], ans;void add(int x, int y, ll z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}priority_queue&lt;pair&lt;int, int&gt; &gt;q;void spfa() {    memset(dist, 0x3f, sizeof(dist));    q.push(make_pair(0, s));    dist[s] = -l;    vis[s] = 1;    while (q.size()) {        int x = q.top().second;        q.pop();        vis[x] = 0;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (dist[y] &gt; dist[x] + z) {                dist[y] = dist[x] + z;                if (!vis[y]) {                    if (++cnt[y] &gt;= n) {                        printf(\"-1\");                        flag=1;                        exit(0);                    }                    vis[y] = 1;                    q.push(make_pair(-dist[y], y));                }            }        }    }}int main() {    scanf(\"%d%d%d%d%d\", &amp;l, &amp;m, &amp;n, &amp;k, &amp;s);    while (m--) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        add(x, y, -l);    }    while (k--) {        int x, y, z;        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);        add(x, y, z - l);    }    spfa();    for (int i = 1; i &lt;= n; i++) {        ans = min(ans, dist[i]);    }    printf(\"%lld\", -ans);    return 0;}\n\nT4. SYOJ #1030 / Luogu P1266\n奶牛开车 / 速度限制【大体思路】　　最短路（Dijkstra）\n【详解】　　这道题特别的就是要用两个量来计算边权，多加一维就能解决。然后就是输出路径，用个  数组就可以实现类似链表的功能，再用个递归向上查倒着输出就好了。\n　　思路真的不难，细节也是真的很多，调了快一节课。需要仔细处理  为  时的计算方式。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int inf = 1e9;const int N = 205;const int T = 1005;const int M = 1e5 + 10;int n, m, a, b, c, maxx;int head[N], edge[M * 2], nxt[M * 2], w[M * 2], V[M * 2], tot;double dist[T][T];bool vis[T][T];pair&lt;double, int&gt;pre[T][T];void add(int x, int y, int z, int v) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    V[tot] = v;    head[x] = tot;}priority_queue&lt;pair&lt;double, pair&lt;int, int&gt; &gt; &gt;q;void dijkstra() {    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= 500; j++) {            dist[i][j] = 1e9;        }    }    dist[a][c] = 0;    q.push(make_pair(0, make_pair(a, c)));    while (q.size()) {        int x = q.top().second.first;        int lv = q.top().second.second;        q.pop();        if (vis[x][lv]) {            continue;        }        vis[x][lv] = 1;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i], v = V[i];            if (vis[y][v]) {                continue;            }            if (!v) {                v = lv;            }            if (dist[y][v] &gt; dist[x][lv] + 1.0 * z / v) {                dist[y][v] = dist[x][lv] + 1.0 * z / v;                pre[y][v].first = x;                pre[y][v].second = lv;                q.push(make_pair(-dist[y][v], make_pair(y, v)));            }        }    }}void print(int x, int v) {    if (x == a) {        printf(\"%d \", x);        return;    }    print(pre[x][v].first, pre[x][v].second);    printf(\"%d \", x);}int main() {    scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b, &amp;c);    while (m--) {        int x, y, z, v;        scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;z, &amp;v);        add(x, y, z, v);    }    dijkstra();    dist[b][maxx] = inf;    for (int i = 0; i &lt;= 500; i++) {        if (dist[b][i] &lt;= dist[b][maxx]) {            maxx = i;        }    }    print(b, maxx);    return 0;}\n","categories":["博客"],"tags":["EE","史尔特尔"]},{"title":"23-9-19-模拟赛题解","url":"/2023/09/27/23-9-19-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"9/19模拟赛题解T1. SYOJ #532 / Luogu P2294 \n区间和速算比赛  / 狡猾的商人【大体思路】　　差分约束（Spfa）+ 前缀和\n【详解】　　经典差分约束模板题。要判有无解，其实就是按照差分约束规则建个图，判断图上有无环，如果有环则无解。\n　　在这里写一下差分约束基本规则方便复习：\n\n　　如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成 “” 的形式，建图后求最短路；\n　　如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成 “” 的形式，建图后求最长路。\n\n　　假设我们现在要求最小值，需要跑最长路，那么现在应该这样建边：\n\n如果 ，则 ，\n\n如果 ，则 \n\n如果 ，则 \n\n如果 ，则 \n\n如果 ，则 \n\n\n　　对于常见需要使用差分约束的问题经常会用到超级源点的思想，没有起点的时候不要忘记用这点小东西。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int N = 2e4 + 10;const int M = 1e6 + 10;const int inf = 0x3f3f3f3f;int t, n, m, flag;int dist[N], vis[N], cnt[N];int head[N], edge[M * 2], nxt[M * 2], w[M * 2], tot;void add(int x, int y, int z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void spfa(int s) {    queue&lt;int&gt;q;    memset(vis, 0, sizeof(vis));    memset(cnt, 0, sizeof(cnt));    memset(dist, 0x3f, sizeof(dist));    dist[s] = 0;    q.push(s);    while (q.size()) {        int x = q.front();        q.pop();        cnt[x]++;        if (cnt[x] &gt; n) {            flag = 1;            return ;        }        vis[x] = 0;        for (int i = head[x]; ~i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (dist[y] &gt; dist[x] + z) {                dist[y] = dist[x] + z;                if (!vis[y]) {                    vis[y] = 1;                    q.push(y);                }            }        }    }}int main() {    scanf(\"%d\", &amp;t);    while (t--) {        memset(head, -1, sizeof(head));        tot = 0;        flag = 0;        scanf(\"%d%d\", &amp;n, &amp;m);        while (m--) {            int x, y, z;            scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);            add(x - 1, y, z);            add(y, x - 1, -z);        }        for (int i = 1; i &lt;= n; i++) {            add(n + 1, i, 0);        }        spfa(n + 1);        if (!flag) {            puts(\"AC\");        } else {            puts(\"WA\");        }    }    return 0;}\n\nT2. SYOJ #644 / Luogu P1197 \n网络破坏 / 星球大战【大体思路】　　逆向思维 + 并查集\n【详解】　　发现好像没见过删点的题，但是删点反过来不就成了建点嘛。然后就是非常基础的思路了，总之就是把题目的操作顺序全倒过来，由最终的散乱状态连接回起始一整块的状态，再把询问倒着输出就完成了。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 4e5 + 5;int n, m, k, tot, fa[N], lis[N];int head[N], edge[N], from[N], nxt[N], ans[N];bool vis[N];void add(int x, int y) {    edge[++tot] = y;    from[tot] = x;    nxt[tot] = head[x];    head[x] = tot;}int fd(int x) {    if (fa[x] == x) {        return x;    }    return fa[x] = fd(fa[x]);}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) {        fa[i] = i;    }    for (int i = 1; i &lt;= m; i++) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        add(x, y);        add(y, x);    }    scanf(\"%d\", &amp;k);    tot = n - k ;    for (int i = 1; i &lt;= k; i++) {        int x;        scanf(\"%d\", &amp;x);        vis[x] = 1;        lis[i] = x;    }    for (int i = 1; i &lt;= m * 2; i++) {        int x = from[i], y = edge[i];        if (!vis[x] &amp;&amp; !vis[y] &amp;&amp; fa[fd(x)] != fa[fd(y)]) {            fa[fd(x)] = fa[fd(y)];            tot--;        }    }    ans[k + 1] = tot;    for (int i = k; i &gt;= 1; i--) {        int x = lis[i];        tot++;        vis[x] = 0;        for (int j = head[x]; j; j = nxt[j]) {            int y = edge[j];            if (!vis[y] &amp;&amp; fa[fd(x)] != fa[fd(y)]) {                fa[fd(x)] = fa[fd(y)];                tot--;            }        }        ans[i] = tot;    }    for (int i = 1; i &lt;= k + 1; i++) {        printf(\"%d\\n\", ans[i]);    }    return 0;}\n","categories":["博客"],"tags":["EE","史尔特尔"]},{"title":"bug论贪与树比","url":"/2023/04/19/bug%E8%AE%BA%E8%B4%AA%E4%B8%8E%E6%A0%91%E6%AF%94/","content":"听着，所谓贪……树比者……                                                                                                                               ——Bugupop\n\n　　予谓贪，信竞之糟粕也。树套比，可为贪之所为，而迅疾于贪，可谓高效之算法，应得众人追捧而传颂。\n　　贪者，乃人之本性，恶极，当聚众人而竭力去贪也。\n　　然今西西弗，垄权而位重，以恶题毒害欧埃尔，其爱贪也，乃题一皆出贪，予以为其水绝而无味，弗如树套比。树套比，又谓先断树套比它赛它，优美捏焉。可力取而用也。其力达亦已悟，解海题而不怠，似上苍之恩泽，而人界无与之相比者。\n　　近贤臣可大猪大发慨词，盛赞树套比，于欧埃界激起反响数声，引得娄叉娄大呼惊叹，连连称绝。可见树比之妙。\n　　树比之美者，非甚于贪者乎？今人称先猪娄之论为树比之说，予嘉之，乃作论贪与树比之说，以记淮安之行也。\n","categories":["谬谈"],"tags":["EE","艾雅法拉"]},{"title":"bug论发电的影响","url":"/2023/04/19/bug%E8%AE%BA%E5%8F%91%E7%94%B5%E7%9A%84%E5%BD%B1%E5%93%8D/","content":"　　著名 AFOer EEbot 曾经说过：\n\n在机房不发电的生活是乏味的、折磨的、绝望的、令人窒息的、令人悲鸣的、令人狞笑的、令人想吃甜司康饼的、令人分崩离析的、令人阴暗地爬行的。\n\n　　我非常认同她的看法。在一分钟内我能够找到一万个理由发电。所以，我主观地得出了结论：我摊牌了，我不发电会死。\n　　对于违背之前承诺过的洗心革面，我深感愧疚，并进行了深刻的反思，因为在一时脑热做出如此影响深远的决定无疑是错误的。关于发电这件关系到这一生命运的事，我应该深思熟虑后再做出选择。对于现在的我来说，不再发电的后果是毁灭性的，并且很难做到，我可能会用所有的精力去遏制自己发电的冲动，导致无法集中在应该做的事情上。\n　　综上，我会选择继续发电，就像英语阅读中读到的那个少年一样，明知咖啡的危害，却还是不得不喝咖啡，我虽知发电的危害，却还是不能完全不发电。既然如此，不如接纳发电，将发电作为生活的一部分，享受、热爱、珍惜可以发电的生活，将发电精神传播到 SY 的每一个角落。所以，明天起，你会见到一个全新的 bug、一个将发电作为每日任务的 bug、一个时刻向往发电的 bug、一个充满活力、激情与欢乐的 bug。而 bug 发生的一切改变，都是发电导致的。\n　　如果再给您一次机会，您还会选择跟 bug 一起发电吗？\n　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——您忠诚的朋友，Bugupop\n","categories":["谬谈"],"tags":["EE","艾雅法拉"]},{"title":"这是一张美丽的头图","url":"/2077/12/13/%E5%A4%B4%E5%9B%BE/","content":"\n\n我真的很喜欢小羊头图跟博客内容一点关系都没有但是我觉得如果每天都能在主页看见小羊的话是会感觉非常幸福的\n","categories":["谬谈"],"tags":["EE","艾雅法拉"]},{"title":"2023-CSP-S1-游记","url":"/2023/09/22/2023-CSP-S1/","content":"Teetering on the edge of Heaven and Hell, \nIs a battle that I cannot fight.\n\n　　哈，时隔 N 天终于想起来写游记了。\n2023/9/15　　因为是在本校考试，学校周五提前20分钟放学布置考场，于是高高兴兴回了家开摆。之前做模拟题做的都还不错，正式考试之前心情还是非常放松的，故开始疯狂听歌整理文化课材料，略写了一点作业。\n　　特意找了清北哥，祝他明天rp++，也得到了他的进队祝福 buff，感觉这次初赛还没比就圆满了（\n　　超级期待明天的面基，等不及跟朱老师和 myj 贴贴啦！！！\n2023/9/16赛前：　　非常兴奋，早晨多睡了俩小时，起来先写了点whk作业，随便吃了点什么，很快就到下午了。\n　　临走之前摸了几块糖，想着什么时候想起来就吃一块，防止脑袋干烧炸掉。\n　　提前40分钟到了考场，看到了好多小孩，热热闹闹的感觉头都大了。进门路上碰到了某国际部不知道为啥周六还在学校的初中同学，打了个招呼他居然没啥反应，哈。\n　　到的太早没让进楼，在楼下环视一圈就看到了朱老师和 myj，巧巧巧，我直接扑过去主动出击ttt\n　　高兴地聊了一会儿的天，说到在报名名单上看到了远古时代鸭子的同学都没退役，大家都深有同感，莫名其妙的怀念起来了当初考J组的那段黄金时代。又碰见了清北哥，跟他打了招呼，他问我叫啥，是不是 tcw，我爆笑。\n　　找了一会儿 lmh 没找到，这时候就让进考场了，只好先放弃。看着前面的小孩疯狂地奔跑，大喊大叫，不禁感叹年轻真好。\n　　跟 zmq 和 myj 分开以后在考场门口一扭头就看见了 lmh，问了一下没啥事这个时候就可以进场了，我就做了那个第一个进考场的人，好耶！监考的志愿者小美女在我这安检的时候手忙脚乱了一会儿，感觉萌的嘿嘿。\n　　静坐十来分钟，清北哥找我借了支 2B 铅笔，感觉还挺抽象的。闲的没事听右后方同学跟监考老师聊天，然后后面一群人不知道咋就背起来 int 能存储的最大值是多少，听着听着莫名其妙就紧张起来了。\n　　我的位置13号在教室第一排正中间，开考之前在门口看见了游荡的N，打了个招呼，感觉酷酷的。\n赛时：　　开始考试了，一开始感觉脑子一片空白，写着写着题就突然开始播放音乐，好像是 Adele 的 Oh my god，我一整个傻眼。强迫自己冷静了一些，好像状态好一点了，于是接着做题。\n　　前面15个单选乱蒙了一两个，关于 Linux 操作系统的是真不会，开摆。\n　　大概做到阅读程序那几个恶心的模拟，算了很久算错了心态有点崩，第一大题把题绞尽脑汁答的差不多实在受不了了，就跳了几个题去做后面的。磨磨蹭蹭好歹做到完善程序还剩半个多小时，然后连蒙带猜胡乱分析了一遍涂上答题卡就没再看了。\n　　回头算刚才没算出来的大模拟，这次比较顺利，成功做出了选项有的答案，怒选并改了之前理解错误的几个题，这才放下心来。\n　　临交卷十分钟果然进入了自我怀疑环节，很想改点答案，但是忍住了都没改，相信自己的第一直觉。把答题卡上的答案直接抄到答题纸上就开始发呆，这时候才想起来摸个糖吃。\n赛后：　　然后就收卷了。急急跑出去跟 lmh 一起找朱老师，在楼下等散场，我没带手机，lmh 给朱老师发了条消息请求碰头，在这期间遇到了 Petercao 老师、迷茫的 lz、准备离开的 myj、好像在闲逛的 lqz 一伙人，然后没过多久就看到了反向跑过来的朱老师。\n　　往外走，朱老师说到快速幂O(N)的诈骗题，我才突然想起确实是这样，当时做的时候有点小疑问没当回事，反应过来没记忆化时间确实变成O(N)了。。。\n　　溜达出门，发现门口被X组家长围得水泄不通，被创飞了，挤着挤着就发现只剩俺一个力。\n　　去吃了烤鱼，然后就急着估分，我把答案记在准考证上了，先对着洛谷上的答案估了一次，大概 70 来分，一下就放松下来了。\n　　没过多久小图灵就出了，把答案输完发现正好是 70 分，然后就盼着看大概排名，饭都没怎么吃好。刷了一会儿有道选择分值改成 2 了，又多了 0.5，于是我喜提 70.5 的初赛成绩。\n","categories":["游记"],"tags":["EE","缪尔赛思"]},{"title":"U链","url":"/2076/12/13/%E5%8F%8B%E9%93%BE/","content":"Long live all the mountains we moved,I had the time of my life fighting dragons with you.\n\n   我的敌人了么和   强大可爱的六七折老师   感觉不如范队的萝卜老师   没有楼的AC老师   可能已经离开我们的唐林博文","categories":["公告"],"tags":["EE","艾雅法拉"]},{"title":"23-10-12-模拟赛题解","url":"/2023/10/16/23-10-12-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"When I’m away from you,I’m happier than ever.Wish I could explain it better,I wish it wasn’t true.\n\nT1. SYOJ #26 \n老师的考验没学过数学导致的找 5e6 循环节找了一个半小时。\n看了正解代码后感觉是很有意思的一道题，巧妙地暴露了我一些数学漏洞和大脑缺陷。\n【大体思路】数学\n【详解】要求  的最高位，我们不妨设它的位数是 ，就可以把答案写成  的形式。\n然后把  进行一个表示：\n再把它代回原式，分子也换成以  为底的对数，式子就变成了这样：ans=\\left\\lfloor\\dfrac{10^{n lg2}}{10^{\\left\\lfloor n\\lg2\\right\\rfloor}}\\right\\rfloor\n最后的最后就是求这个式子了：ans=\\left\\lfloor10^{ {n lg2}-{\\left\\lfloor n\\lg2\\right\\rfloor} }\\right\\rfloor\n【代码】#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;typedef long double ld;ld lg2 = log10(2), n;int t;int main() {    scanf(\"%d\", &amp;t);    while (t--) {        scanf(\"%Lf\", &amp;n);        ll p = (ld)n * lg2;        printf(\"%d\\n\", (int)pow(10, (ld)n * lg2 - p));    }    return 0;}\n","categories":["博客"],"tags":["EE","史尔特尔"]}]