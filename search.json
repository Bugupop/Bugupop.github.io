[{"title":"2023-CSP-S1-游记","url":"/2023/09/22/2023-CSP-S1/","content":"Teetering on the edge of Heaven and Hell,Is a battle that I cannot fight.\n\n　　哈，时隔 N 天终于想起来写游记了。\n2023/9/15　　因为是在本校考试，学校周五提前20分钟放学布置考场，于是高高兴兴回了家开摆。之前做模拟题做的都还不错，正式考试之前心情还是非常放松的，故开始疯狂听歌整理文化课材料，略写了一点作业。\n　　特意找了清北哥，祝他明天rp++，也得到了他的进队祝福 buff，感觉这次初赛还没比就圆满了（\n　　超级期待明天的面基，等不及跟朱老师和 myj 贴贴啦！！！\n2023/9/16赛前：　　非常兴奋，早晨多睡了俩小时，起来先写了点whk作业，随便吃了点什么，很快就到下午了。\n　　临走之前摸了几块糖，想着什么时候想起来就吃一块，防止脑袋干烧炸掉。\n　　提前40分钟到了考场，看到了好多小孩，热热闹闹的感觉头都大了。进门路上碰到了某国际部不知道为啥周六还在学校的初中同学，打了个招呼他居然没啥反应，哈。\n　　到的太早没让进楼，在楼下环视一圈就看到了朱老师和 myj，巧巧巧，我直接扑过去主动出击ttt\n　　高兴地聊了一会儿的天，说到在报名名单上看到了远古时代鸭子的同学都没退役，大家都深有同感，莫名其妙的怀念起来了当初考J组的那段黄金时代。又碰见了清北哥，跟他打了招呼，他问我叫啥，是不是 tcw，我爆笑。\n　　找了一会儿 lmh 没找到，这时候就让进考场了，只好先放弃。看着前面的小孩疯狂地奔跑，大喊大叫，不禁感叹年轻真好。\n　　跟 zmq 和 myj 分开以后在考场门口一扭头就看见了 lmh，问了一下没啥事这个时候就可以进场了，我就做了那个第一个进考场的人，好耶！监考的志愿者小美女在我这安检的时候手忙脚乱了一会儿，感觉萌的嘿嘿。\n　　静坐十来分钟，清北哥找我借了支 2B 铅笔，感觉还挺抽象的。闲的没事听右后方同学跟监考老师聊天，然后后面一群人不知道咋就背起来 int 能存储的最大值是多少，听着听着莫名其妙就紧张起来了。\n　　我的位置13号在教室第一排正中间，开考之前在门口看见了游荡的N，打了个招呼，感觉酷酷的。\n赛时：　　开始考试了，一开始感觉脑子一片空白，写着写着题就突然开始播放音乐，好像是 Adele 的 Oh my god，我一整个傻眼。强迫自己冷静了一些，好像状态好一点了，于是接着做题。\n　　前面15个单选乱蒙了一两个，关于 Linux 操作系统的是真不会，开摆。\n　　大概做到阅读程序那几个恶心的模拟，算了很久算错了心态有点崩，第一大题把题绞尽脑汁答的差不多实在受不了了，就跳了几个题去做后面的。磨磨蹭蹭好歹做到完善程序还剩半个多小时，然后连蒙带猜胡乱分析了一遍涂上答题卡就没再看了。\n　　回头算刚才没算出来的大模拟，这次比较顺利，成功做出了选项有的答案，怒选并改了之前理解错误的几个题，这才放下心来。\n　　临交卷十分钟果然进入了自我怀疑环节，很想改点答案，但是忍住了都没改，相信自己的第一直觉。把答题卡上的答案直接抄到答题纸上就开始发呆，这时候才想起来摸个糖吃。\n赛后：　　然后就收卷了。急急跑出去跟 lmh 一起找朱老师，在楼下等散场，我没带手机，lmh 给朱老师发了条消息请求碰头，在这期间遇到了 Petercao 老师、迷茫的 lz、准备离开的 myj、好像在闲逛的 lqz 一伙人，然后没过多久就看到了反向跑过来的朱老师。\n　　往外走，朱老师说到快速幂O(N)的诈骗题，我才突然想起确实是这样，当时做的时候有点小疑问没当回事，反应过来没记忆化时间确实变成O(N)了。。。\n　　溜达出门，发现门口被X组家长围得水泄不通，被创飞了，挤着挤着就发现只剩俺一个力。\n　　去吃了烤鱼，然后就急着估分，我把答案记在准考证上了，先对着洛谷上的答案估了一次，大概 70 来分，一下就放松下来了。\n　　没过多久小图灵就出了，把答案输完发现正好是 70 分，然后就盼着看大概排名，饭都没怎么吃好。刷了一会儿有道选择分值改成 2 了，又多了 0.5，于是我喜提 70.5 的初赛成绩。\n","categories":["游记"],"tags":["EE","缪尔赛思"]},{"title":"2023-CSP-S2-游记","url":"/2023/10/24/2023-CSP-S2/","content":"等待着你等待你慢慢的靠近我陪着我长长的夜到尽头别让我独自守候\n\n2023/10/20早晨　　跟机房大多数人一起买的 11:50 的火车票，上午上了三节文化课以后还去跑了个操，真是有闲情雅致……虽然下了楼就开始后悔了，呜呜。之后去机房玩了半个小时到 11:30 坐大巴去火车站。\n中午　　上车的时候祝了每个人考上清华北大，一开车就有点小晕，不过不影响一路上还是高高兴兴的。\n　　到了火车站陪 lmh 等了一会儿她妈妈送身份证过来，然后就顺利上车启动了。\n　　坐的那节车厢上有很多同学，不过人坐得满满的没好意思跑出来玩，只在QQ上聊了一会儿天，大概刷了一会儿动态看了几个炸裂瓜条，喝了一大杯 lmh 给的奶茶，那火车晃晃悠悠还挺晕，就只好去睡觉了。睡得挺香的，最后还是被我妈聊天的声音吵醒的。\n下午　　打车去了酒店，办入住的时候看见旁边有个可能上初一的小姑娘，扔下作业直冲在大屏幕，在上面点了马嘉祺的歌然后边扭边唱的很开心。。。直接被吓晕了 wflbb。\n　　回去收拾了收拾，叫着 lmh 去吃饭。吃了一顿无敌爆炸好吃的炒菜，对那道牙签扎的培根茄子印象非常深刻，实在是太牛啦！因为晕车而萎蔫的我直接满血复活！然后去买了点糖和牛肉干，准备第二天不会写题就直接开吃。\n晚上　　然后就去试机，绕了好一圈才找到考场，然后进去了发现我座上竟然既没有键盘也没有鼠标，监考老师让我换到对面去随便找了个座位坐下，感觉挺抽象的。输地址的时候多加了个后缀，导致我又换了一台机器，最后还是通过看隔壁人咋搞的才成功下到文件。试了试虚拟机，先是被突然消失的鼠标吓得不轻，百度了半天怎么退出虚拟机，然后又发现找lz临时请教的命令老是报错，直接被整自闭了。大不了不测就是了！（后来发现是文件没加后缀名，蠢哭了\n　　试完机在大门口等了一会儿朱老师面基，开心！然后去打车的时候还面到了 myj，开心！在酒店楼下发现朱老师的酒店在我们酒店旁边，拍了张合影，开心！\n　　不过回酒店以后越学越焦虑，背了一会儿扩栈指令，然后干脆直接摆烂。甚至去动漫社招新群里硬着头皮聊了两句天。正好我妈开始看李健演唱会，我就随便听了一耳朵歌，想起来听过一个王晰的特别牛逼的翻唱版本，单曲循环了一会儿。不得不说，偶尔听听抒情中文歌还挺令人心情舒畅的。\n　　是 一生守候，听过以后人直接没有顾虑地升华了。好耶！\n2023/10/21早晨　　好！一起来就很没胃口，浑身不得劲。随便吃了两口早饭，然后看了看数学相关的板子。J 组题很快被爆出来了，扫了两眼感觉很熟悉，随便口胡了一下玩，对下午比赛还 蛮有信心 蛮期待的。\n　　点了杯从前一天晚上就想喝的芋泥奶茶，但是喝到一半就没啥胃口了，悲。\n中午　　吃了饺子，味还不错，但是也没啥心情吃，发现一上午就这么发呆过去了。闲着也是闲着，就早早退房在楼下等，还是感觉不太舒服，可能是紧张的。\n下午　　进了学校拍合影，还被激情澎湃的清北哥喊口号吓了一跳。今年考场外面被家长塞的满满的，感觉很抽象，艰难地挤进去去了考场。\n　　心情很复杂，紧张使我面色凝重，实际心里并没啥实际感受，就平平常常的开始发呆。\n　　考场里，阳光从窗帘的一个缝刺进来直射在我脸上，我坐了一会儿脸就开始发烫，跟光决斗了半天我还是认输了，最终决定让监考老师帮忙拉了下窗帘。\n　　没发密码之前先看了眼样例，打开一个 game 被吓了一跳，不想碰字符串他还真就出字符串是罢。。。慌忙关掉再开一个，struct 一眼大模拟，一种 21 年 J 组 T3 的既视感使我颤抖。剩下的没啥感觉，平复了下心情就快开考了，打了个对拍板子试了试，发现好像暂时没法用，就扔那去了。试着跑了一下，发现旁边老哥似乎是被呼呼窜的数据吓得瞟了一眼，好好好。\n　　开考读题，第一题感觉很好写，没咋仔细看就跳了。第二题难评，像几个月前的 N oi 风格，但是我还真对之前那些题的解法一点印象也没有，有点麻爪，赶紧跳了。T3 果真像坨大便，但是好像挺好懂，幸亏内心足够坚定，从这一刻就没打算好好写模拟，不然可能整场就折进去一半（。然后呢，看过 T4 后脑瘫的我打算从 T4 入手写暴力。这脑瘫到我现在想起来还是想大呼脑瘫/cf。\n　　其实可以猜到，在瞪了 T4 十五分钟以后我就放弃了，本来想的二分 + 搜搜搜的码不太好实现，没敢深入思考，反而脑子里面被整的乱七八糟的了。\n　　战术吃糖喝水，老老实实打 T1。挺顺利，又读了五分钟题以后用了二十分钟写出了一坨大便，花了十分钟输出了好多中间过程调试，过第一个样例以后略剪了下枝玩，乱测了下样例二发现过了，也没看样例是个啥玩意就自信下一题了。\n　　然后一边再读一遍 T2 一边考虑 T4 特殊性质，T2 试图写区间 dp，但是死活调不出来，写到一半感觉做法假了，还是决定先把 T2 模拟栈判回文串的暴力打了，方便对拍，再看有没有机会想到办法优化。\n　　暴力写完发现离结束还剩不到一个半小时了，又去瞪 T4，乱糊了点二分，然后瞪式子，瞪不出来，也调不出来，还有一种莫名其妙的做物理运动学题的感觉，烦。\n　　吃了个牛肉干，放空了一下大脑，T4 干脆直接不打了，想去打打 T3 没有结构体的部分分，但是这时候就有点慌了，没动脑子乱写一通，象征性的造了个数据测测，因为看了一圈样例也没有这个性质的，就直接把码扔那了，希望能骗点分。\n　　然后其实又去写 T4 了，测来测去，本来二分还能跑出来一些奇怪的数据的，但是调到最后全都输出 1e9 了，也真是服了，一怒之下就把这稳定输出 1e9 的二分 dfs 直接交上了，哈哈。\n　　结束的时候在 T4 顶上写了这个，还意外上了迷惑行为大赏。\n\n　　其实这里的 B 指的是性质 B（）\n　　交代码的时候没听见老师让干什么，等散场的时候让老师帮忙调了一下，但是我好像在拿东西的时候不小心碰到鼠标又把老师给开的极域关掉了（ 想到结束了大家都走了再动鼠标好像不太好，就没管直接离场了。\n　　出去以后更是心情复杂，因为感觉一场全打唐氏暴力了，什么成分啊。\n　　N 看见我和 lmh 以后说看我们这么高兴一定发挥的都特别好，还说之前模拟赛押到了前两道题。我还想着我那 T2 暴力都不敢出声了/kk\n晚上　　然后就走了，在大门口等了好久的出租车，那个司机开车有点不顾人死活的彪，晕车恶心得我趴那起不来了。到火车站还直犯恶心，过了好久才有点胃口吃了买的晚饭烧饼。有一说一那个把子肉烧饼真的很好吃！\n　　离发车时间还比较长，在那跟 lmh 讨论琢磨了一会儿 T1 的样例 2，发现我当时没细想样例是怎么来的还是个正确的做法，绕了挺长时间才想明白为啥转两个数的可能结果有 2 种。\n　　发现 PeterBei 老师跟我们还是一趟火车，不错不错。还看到了之前在鸭子那边一起集过训的 psq，不过没打招呼（对手指。\n　　上车以后开始怒刷 小秃驴 小图灵，想看看能拿点什么 pe 分。等得着急了，去找 Bei 老师上云斗测了个码，得了 100+35+0+5 分，看发挥的那个样子，对这个分还挺满意的了，不过T3真就一分不得呢，呜呜。\n　　然后就是开心地边吃海苔边看前座打雀魂，管他呢。\n　　最后的最后，飞速回家啦。\nend　　虽然有点遗憾，但是我的 2023 CSP-S2 之旅就这么结束啦。\n","categories":["游记"],"tags":["EE","缪尔赛思"]},{"title":"23-10-12-模拟赛题解","url":"/2023/10/16/23-10-12-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"When I’m away from you,I’m happier than ever.Wish I could explain it better,I wish it wasn’t true.\n\nT1. SYOJ #26 \n老师的考验没学过数学导致的找 5e6 循环节找了一个半小时。\n看了正解代码后感觉是很有意思的一道题，巧妙地暴露了我一些数学漏洞和大脑缺陷。\n【大体思路】数学\n【详解】要求  的最高位，我们不妨设它的位数是 ，就可以把答案写成  的形式。\n然后把  进行一个表示：\n再把它代回原式，分子也换成以  为底的对数，式子就变成了这样：ans=\\left\\lfloor\\dfrac{10^{n lg2}}{10^{\\left\\lfloor n\\lg2\\right\\rfloor}}\\right\\rfloor\n最后的最后就是求这个式子了：ans=\\left\\lfloor10^{ {n lg2}-{\\left\\lfloor n\\lg2\\right\\rfloor} }\\right\\rfloor\n【代码】#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;typedef long double ld;ld lg2 = log10(2), n;int t;int main() {    scanf(\"%d\", &amp;t);    while (t--) {        scanf(\"%Lf\", &amp;n);        ll p = (ld)n * lg2;        printf(\"%d\\n\", (int)pow(10, (ld)n * lg2 - p));    }    return 0;}\n","categories":["题解"],"tags":["EE","史尔特尔"]},{"title":"23-11-8-模拟赛题解","url":"/2023/11/08/23-11-8%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"可愛い顔した hero\nお姫様じゃないの\n強気で戦う\n運命なんて変えてゆくわ\n\nT2. SYOJ #1929\n猫猫和矩阵（makrix）是赛时手玩样例摸索出来的正解之外的新做法，正解是纯归纳法，我这个加了一点一个前缀和转换的思想，从某种意义上讲，这样好像更具象一些，愚蠢但有意思，就是实现略微麻烦点。\n【大体思路】前缀和 + 归纳法 + 单调栈\n【详解】首先先来观察题目中的式子：\n\n移项以后得到：\n\n感觉有点像二维前缀和？\n顺着这个思路，画个图看一下：\n\n上面就是给出的矩阵，就把它看成一个前缀和数组。\n取里面的一个子矩形 ，也就是从  到  这个矩形。首先我们知道，已知一个前缀和数组，我们可以逆推出它的原数组。\n设由矩形  逆推得到的原数组是  数组，套进刚才我们推出的式子，可以得到：AC矩形  满足 整个 A 数组的和 &lt;= A 中有颜色部分的和 这个结论。\n换种说法，就是：若 A 中白色矩形之和 &lt;= 0，则  是一个AC矩形。\n一个AK矩形的所有子矩形都是AC矩形，所以通过归纳法就可以知道一个AK矩形  对应的  数组 除了第一行和第一列以外，剩余部分中的每个数一定都是非正数。这个归纳法的过程与老师上课讲解的正解的过程相同。\n举两个例子：\n\n左侧是样例1推出的  数组，右侧是样例2推出的  数组。\n红框内的就是  中最大的一个 “除第一行和第一列外其余位置都为非正数的矩形”，恰好就是它本身。\n也就是说，我们现在只要找到  中最大的 “除第一行和第一列外剩下位置全负的矩形“，这道题就结束了。\n这个问题用悬线法或是单调栈之类的解法都能做，但是用这种解法可能需要处理的细节会多一些，比如除去第一行和第一列的操作。\n【代码】#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1e3 + 5;int n, m, l[N][N], r[N][N], len[N][N], w[N];int s[N], top, res, ans, a[N][N], b[N][N];int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    ans = max(n, m);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            scanf(\"%d\", &amp;b[i][j]);            a[i][j] = b[i][j] - (b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]);            if (a[i][j] &lt;= 0 &amp;&amp; j == 1) {                a[i][j] = 1;            }        }    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            if (a[i][j] &lt;= 0) {                if (a[i][j - 1] &gt; 0) {                    l[i][j] = j;                } else {                    l[i][j] = l[i][j - 1];                }            } else {                l[i][j] = j;            }        }        r[i][m + 1] = m;        for (int j = m; j &gt;= 1; j--) {            if (a[i][j] &lt;= 0) {                if (a[i][j + 1] &gt; 0) {                    r[i][j] = j;                } else {                    r[i][j] = r[i][j + 1];                }            } else {                r[i][j] = j;            }        }    }    for (int j = 1; j &lt;= m; j++) {        for (int i = 2; i &lt;= n; i++) {            len[i][j] = r[i][j] - l[i][j] + 1;            if (a[i][j] &gt; 0) {                len[i][j] = 0;            }        }    }    for (int j = 1; j &lt;= m; j++) {        top = 0, res = 0;        for (int i = 2; i &lt;= n + 1; i++) {            if (len[i][j] &gt; s[top]) {                s[++top] = len[i][j];                w[top] = 1;            } else {                int wid = 0;                while (s[top] &gt; len[i][j]) {                    wid += w[top];                    res = max(res, (wid + 1) * (s[top] + 1));                    top--;                }                s[++top] = len[i][j];                w[top] = wid + 1;            }        }        ans = max(ans, res);    }    printf(\"%d\", ans);    return 0;}\n","categories":["题解"],"tags":["EE","史尔特尔"]},{"title":"23-9-19-模拟赛题解","url":"/2023/09/27/23-9-19-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"9/19模拟赛题解T1. SYOJ #532 / Luogu P2294 \n区间和速算比赛  / 狡猾的商人【大体思路】　　差分约束（Spfa）+ 前缀和\n【详解】　　经典差分约束模板题。要判有无解，其实就是按照差分约束规则建个图，判断图上有无环，如果有环则无解。\n　　在这里写一下差分约束基本规则方便复习：\n\n　　如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成 “” 的形式，建图后求最短路；\n　　如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成 “” 的形式，建图后求最长路。\n\n　　假设我们现在要求最小值，需要跑最长路，那么现在应该这样建边：\n\n如果 ，则 ，\n\n如果 ，则 \n\n如果 ，则 \n\n如果 ，则 \n\n如果 ，则 \n\n\n　　对于常见需要使用差分约束的问题经常会用到超级源点的思想，没有起点的时候不要忘记用这点小东西。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int N = 2e4 + 10;const int M = 1e6 + 10;const int inf = 0x3f3f3f3f;int t, n, m, flag;int dist[N], vis[N], cnt[N];int head[N], edge[M * 2], nxt[M * 2], w[M * 2], tot;void add(int x, int y, int z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void spfa(int s) {    queue&lt;int&gt;q;    memset(vis, 0, sizeof(vis));    memset(cnt, 0, sizeof(cnt));    memset(dist, 0x3f, sizeof(dist));    dist[s] = 0;    q.push(s);    while (q.size()) {        int x = q.front();        q.pop();        cnt[x]++;        if (cnt[x] &gt; n) {            flag = 1;            return ;        }        vis[x] = 0;        for (int i = head[x]; ~i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (dist[y] &gt; dist[x] + z) {                dist[y] = dist[x] + z;                if (!vis[y]) {                    vis[y] = 1;                    q.push(y);                }            }        }    }}int main() {    scanf(\"%d\", &amp;t);    while (t--) {        memset(head, -1, sizeof(head));        tot = 0;        flag = 0;        scanf(\"%d%d\", &amp;n, &amp;m);        while (m--) {            int x, y, z;            scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);            add(x - 1, y, z);            add(y, x - 1, -z);        }        for (int i = 1; i &lt;= n; i++) {            add(n + 1, i, 0);        }        spfa(n + 1);        if (!flag) {            puts(\"AC\");        } else {            puts(\"WA\");        }    }    return 0;}\n\nT2. SYOJ #644 / Luogu P1197 \n网络破坏 / 星球大战【大体思路】　　逆向思维 + 并查集\n【详解】　　发现好像没见过删点的题，但是删点反过来不就成了建点嘛。然后就是非常基础的思路了，总之就是把题目的操作顺序全倒过来，由最终的散乱状态连接回起始一整块的状态，再把询问倒着输出就完成了。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 4e5 + 5;int n, m, k, tot, fa[N], lis[N];int head[N], edge[N], from[N], nxt[N], ans[N];bool vis[N];void add(int x, int y) {    edge[++tot] = y;    from[tot] = x;    nxt[tot] = head[x];    head[x] = tot;}int fd(int x) {    if (fa[x] == x) {        return x;    }    return fa[x] = fd(fa[x]);}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) {        fa[i] = i;    }    for (int i = 1; i &lt;= m; i++) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        add(x, y);        add(y, x);    }    scanf(\"%d\", &amp;k);    tot = n - k ;    for (int i = 1; i &lt;= k; i++) {        int x;        scanf(\"%d\", &amp;x);        vis[x] = 1;        lis[i] = x;    }    for (int i = 1; i &lt;= m * 2; i++) {        int x = from[i], y = edge[i];        if (!vis[x] &amp;&amp; !vis[y] &amp;&amp; fa[fd(x)] != fa[fd(y)]) {            fa[fd(x)] = fa[fd(y)];            tot--;        }    }    ans[k + 1] = tot;    for (int i = k; i &gt;= 1; i--) {        int x = lis[i];        tot++;        vis[x] = 0;        for (int j = head[x]; j; j = nxt[j]) {            int y = edge[j];            if (!vis[y] &amp;&amp; fa[fd(x)] != fa[fd(y)]) {                fa[fd(x)] = fa[fd(y)];                tot--;            }        }        ans[i] = tot;    }    for (int i = 1; i &lt;= k + 1; i++) {        printf(\"%d\\n\", ans[i]);    }    return 0;}\n","categories":["题解"],"tags":["EE","史尔特尔"]},{"title":"23-9-9-模拟赛题解","url":"/2023/09/13/23-9-9-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"Drop everything now,Meet me in the pouring rain.Kiss me on the sidewalk,Take away the pain.\n\ngogogobky\nT1. SYOJ #1007 / Luogu P3199\n环形跑【大体思路】　　二分 + 0/1 分数规划 + Spfa（DFS优化判负环）\n【详解】　　有一说一，其实不知道 0/1 分数规划是啥也能做。正向考虑找边权平均值最小的环非常困难，所以我们不妨从结果入手反推找有没有符合要求的环。这样二分的思路就明确了，然后就突然想到之前做过一道关于平均值的二分题，这里搬个当时写的题解看看。\n\n　　我们把环上的每个元素都减去二分出的平均值，在这个基础上跑最短路找环。因为要找的是平均值最小的环，正好与上面这道题相反，如果找到了负环就说明有比二分出的平均值符合要求且存在更优的答案，可以再接着缩小二分范围。\n　　这里的 Spfa 使用递归写法，求负环比较方便。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 5e3 + 5;const int M = 1e5 + 5;const double inf = 1e9;const double eps = 1e-10;int n, m;int head[N], edge[M], nxt[M], w[M], tot;double l = -inf, r = inf, vis[N], f, dist[N];void add(int x, int y, double z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void check(int x, double d) {    vis[x] = 1;    for (int i = head[x]; i; i = nxt[i]) {        int y = edge[i];        double z = w[i];        if (dist[y] &gt; dist[x] + z - d) {            if (vis[y] || f) {                f = 1;                break;            }            dist[y] = dist[x] + z - d;            check(y, d);        }    }    vis[x] = 0;    return ;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++) {        int a, b;        double c;        scanf(\"%d%d%lf\", &amp;a, &amp;b, &amp;c);        add(a, b, c);    }    while (r - l &gt; eps) {        memset(dist, 0, sizeof(dist));        memset(vis, 0, sizeof(vis));        f = 0;        double mid = (l + r) / 2;        for (int i = 1; i &lt;= n; i++) {            check(i, mid);            if (f) {                break;            }        }        if (f) {            r = mid;        } else {            l = mid;        }    }    if (r == inf) {        printf(\"No solution\");    } else {        printf(\"%.8lf\", l);    }    return 0;}\n\nT2. SYOJ #1019 / Luogu P5764 \n奶牛串门 / 新年好【大体思路】　　枚举 + 最短路（Dijkstra）\n【详解】　　我们不知道以一个怎样的顺序可以使走出的距离最短，但是知道一共只有五个点，把这所有的可能性都枚举一遍也只有  种情况，还是很能接受的。\n　　事实上，在看到这道题的时候第一想法是分层图，把点建五层，从最下面一层开始，每走到一个新的目标点就升一层，最终在第五层统计答案。在写的时候遇到了一个困难，就是可能会在一个环上一直重复走爬层，虽然是走到了足够多的目标点，但是是重复计数的。给目标点原来的编号打标记是不行的，只能硬判断是不是走到了没走过的目标点，以及还需要考虑目标点是可以重复到达的，但是不会计数。略微有亿点点麻烦。感觉这个做法理论上是可以的，但是不知道哪里写挂了，死活调不对，于是遗憾离场。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int inf = 0x3fffffff;const int N = 5e4 + 5;const int M = 1e6 + 10;int n, m, ans = inf, dist[6][N], t[6];int head[N], edge[M], nxt[M], w[M], tot;int b[6] = {1, 2, 3, 4, 5};bool vis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void add(int x, int y, int z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void dij(int k) {    memset(vis, 0, sizeof(vis));    dist[k][t[k]] = 0;    q.push(make_pair(0, t[k]));    while (!q.empty( )) {        int x = q.top().second;        q.pop();        if (vis[x]) {            continue;        }        vis[x] = 1;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (vis[y]) {                continue;            }            dist[k][y] = min(dist[k][y], dist[k][x] + z);            q.push(make_pair(-dist[k][y], y));        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= 5; i++) {        scanf(\"%d\", &amp;t[i]);    }    t[0] = 1;    for (int i = 1; i &lt;= m; i++) {        int x, y, z;        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);        add(x, y, z);        add(y, x, z);    }    memset(dist, 0x3f, sizeof(dist));    for (int i = 0; i &lt;= 5; i++) {        dij(i);    }    ans = inf;    do {        int res = dist[0][t[b[0]]];        for (int j = 0; j &lt;= 3; j++) {            res += dist[b[j]][t[b[j + 1]]];        }        ans = min(ans, res);    } while (next_permutation(b, b + 5));    printf(\"%d\", ans);    return 0;}\n\nT3. SYOJ #1020 / Luogu P1938 / [USACO09NOV] \n阿龙打工 / Job Hunt S【大体思路】　　Spfa判负环\n【详解】　　比赛开始30分钟静坐灵光乍现产物。\n　　是看到可以无限赚钱的特判联想到了负环的性质，噶的一下就想建个负权边直接跑 Spfa，怒打码一测就发现好像还真有点意思。更有意思的是，当时根本没看见数据范围小小的很可爱适合 Floyd，然后在码里敲了下面这段：\n//啊？咋没记得第一次看的时候数据范围可以跑 Floyd ，所以用了 Spfa\n//等我写个对拍看看\n　　实际上 Floyd 根本没打。\n　　Spfa 跑的还是略快一点的。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int N = 5e3 + 5;const int M = 1e5 + 5;int n, m, l, k, s;int head[N], edge[M * 2], nxt[M * 2], tot, cnt[N];bool vis[N],flag;ll w[M * 2], dist[N], ans;void add(int x, int y, ll z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}priority_queue&lt;pair&lt;int, int&gt; &gt;q;void spfa() {    memset(dist, 0x3f, sizeof(dist));    q.push(make_pair(0, s));    dist[s] = -l;    vis[s] = 1;    while (q.size()) {        int x = q.top().second;        q.pop();        vis[x] = 0;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (dist[y] &gt; dist[x] + z) {                dist[y] = dist[x] + z;                if (!vis[y]) {                    if (++cnt[y] &gt;= n) {                        printf(\"-1\");                        flag=1;                        exit(0);                    }                    vis[y] = 1;                    q.push(make_pair(-dist[y], y));                }            }        }    }}int main() {    scanf(\"%d%d%d%d%d\", &amp;l, &amp;m, &amp;n, &amp;k, &amp;s);    while (m--) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        add(x, y, -l);    }    while (k--) {        int x, y, z;        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);        add(x, y, z - l);    }    spfa();    for (int i = 1; i &lt;= n; i++) {        ans = min(ans, dist[i]);    }    printf(\"%lld\", -ans);    return 0;}\n\nT4. SYOJ #1030 / Luogu P1266\n奶牛开车 / 速度限制【大体思路】　　最短路（Dijkstra）\n【详解】　　这道题特别的就是要用两个量来计算边权，多加一维就能解决。然后就是输出路径，用个  数组就可以实现类似链表的功能，再用个递归向上查倒着输出就好了。\n　　思路真的不难，细节也是真的很多，调了快一节课。需要仔细处理  为  时的计算方式。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int inf = 1e9;const int N = 205;const int T = 1005;const int M = 1e5 + 10;int n, m, a, b, c, maxx;int head[N], edge[M * 2], nxt[M * 2], w[M * 2], V[M * 2], tot;double dist[T][T];bool vis[T][T];pair&lt;double, int&gt;pre[T][T];void add(int x, int y, int z, int v) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    V[tot] = v;    head[x] = tot;}priority_queue&lt;pair&lt;double, pair&lt;int, int&gt; &gt; &gt;q;void dijkstra() {    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= 500; j++) {            dist[i][j] = 1e9;        }    }    dist[a][c] = 0;    q.push(make_pair(0, make_pair(a, c)));    while (q.size()) {        int x = q.top().second.first;        int lv = q.top().second.second;        q.pop();        if (vis[x][lv]) {            continue;        }        vis[x][lv] = 1;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i], v = V[i];            if (vis[y][v]) {                continue;            }            if (!v) {                v = lv;            }            if (dist[y][v] &gt; dist[x][lv] + 1.0 * z / v) {                dist[y][v] = dist[x][lv] + 1.0 * z / v;                pre[y][v].first = x;                pre[y][v].second = lv;                q.push(make_pair(-dist[y][v], make_pair(y, v)));            }        }    }}void print(int x, int v) {    if (x == a) {        printf(\"%d \", x);        return;    }    print(pre[x][v].first, pre[x][v].second);    printf(\"%d \", x);}int main() {    scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b, &amp;c);    while (m--) {        int x, y, z, v;        scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;z, &amp;v);        add(x, y, z, v);    }    dijkstra();    dist[b][maxx] = inf;    for (int i = 0; i &lt;= 500; i++) {        if (dist[b][i] &lt;= dist[b][maxx]) {            maxx = i;        }    }    print(b, maxx);    return 0;}\n","categories":["题解"],"tags":["EE","史尔特尔"]},{"title":"bug论发电的影响","url":"/2023/04/19/bug%E8%AE%BA%E5%8F%91%E7%94%B5%E7%9A%84%E5%BD%B1%E5%93%8D/","content":"　　著名 AFOer EEbot 曾经说过：\n\n在机房不发电的生活是乏味的、折磨的、绝望的、令人窒息的、令人悲鸣的、令人狞笑的、令人想吃甜司康饼的、令人分崩离析的、令人阴暗地爬行的。\n\n　　我非常认同她的看法。在一分钟内我能够找到一万个理由发电。所以，我主观地得出了结论：我摊牌了，我不发电会死。\n　　对于违背之前承诺过的洗心革面，我深感愧疚，并进行了深刻的反思，因为在一时脑热做出如此影响深远的决定无疑是错误的。关于发电这件关系到这一生命运的事，我应该深思熟虑后再做出选择。对于现在的我来说，不再发电的后果是毁灭性的，并且很难做到，我可能会用所有的精力去遏制自己发电的冲动，导致无法集中在应该做的事情上。\n　　综上，我会选择继续发电，就像英语阅读中读到的那个少年一样，明知咖啡的危害，却还是不得不喝咖啡，我虽知发电的危害，却还是不能完全不发电。既然如此，不如接纳发电，将发电作为生活的一部分，享受、热爱、珍惜可以发电的生活，将发电精神传播到 SY 的每一个角落。所以，明天起，你会见到一个全新的 bug、一个将发电作为每日任务的 bug、一个时刻向往发电的 bug、一个充满活力、激情与欢乐的 bug。而 bug 发生的一切改变，都是发电导致的。\n　　如果再给您一次机会，您还会选择跟 bug 一起发电吗？\n　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——您忠诚的朋友，Bugupop\n","categories":["谬谈"],"tags":["EE","艾雅法拉"]},{"title":"bug论贪与树比","url":"/2023/04/19/bug%E8%AE%BA%E8%B4%AA%E4%B8%8E%E6%A0%91%E6%AF%94/","content":"听着，所谓贪……树比者……                                                                                                                               ——Bugupop\n\n　　予谓贪，信竞之糟粕也。树套比，可为贪之所为，而迅疾于贪，可谓高效之算法，应得众人追捧而传颂。\n　　贪者，乃人之本性，恶极，当聚众人而竭力去贪也。\n　　然今西西弗，垄权而位重，以恶题毒害欧埃尔，其爱贪也，乃题一皆出贪，予以为其水绝而无味，弗如树套比。树套比，又谓先断树套比它赛它，优美捏焉。可力取而用也。其力达亦已悟，解海题而不怠，似上苍之恩泽，而人界无与之相比者。\n　　近贤臣可大猪大发慨词，盛赞树套比，于欧埃界激起反响数声，引得娄叉娄大呼惊叹，连连称绝。可见树比之妙。\n　　树比之美者，非甚于贪者乎？今人称先猪娄之论为树比之说，予嘉之，乃作论贪与树比之说，以记淮安之行也。\n","categories":["谬谈"],"tags":["EE","艾雅法拉"]},{"title":"这是一张美丽的头图","url":"/2077/12/13/%E5%A4%B4%E5%9B%BE/","content":"\n\n我真的很喜欢小羊头图跟博客内容一点关系都没有但是我觉得如果每天都能在主页看见小羊的话是会感觉非常幸福的\n","categories":["谬谈"],"tags":["EE","艾雅法拉"]},{"title":"2023-NOIP-游记","url":"/2023/11/21/2023-NOIP/","content":"Baby you and me are a twisted fantasy,Buckle up and take a seat,Hold on tight.\n\n2023的最后一篇 oi 比赛游记——\n2023 NOIP 游记2023/11/17N老师说今天的任务就是放松，调整，于是就真的摆了一天。\n这两天调了化学相对分子质量、网络连接这两道大模拟，还开了一半时间复杂度，没写完就被前来为我们鼓劲的杜老师和沃老师打断施法了。\n剩下的时间都在玩纸牌、猫猫和 rich4。意外发现机房电脑可以运行我笔记本上没法运行的古老 rich4，完了可能三分钟又被F打断施法了。\n中午还聚众开了一中午的盒，很开心。\n晚上去试了机，学校包的大巴没走高架，遇上晚高峰堵了好久，到历二的时候已经挺晚的了，试了试键盘，手感还不错，尝试使用虚拟机但是没启动成，于是就放弃然后走了。\n发现旁边那位 21 年就坐我旁边的名字特别牛逼的冷氏兄弟没有来，以为他自信不试机了来着。\n出去以后看到 peterbei 老师了，然后想去找朱老师，但是朱老师已经走了，只好就这样告别众人跟妈妈去住酒店了。\n酒店条件非常艰苦，点了鸡架和奶茶的外卖，但是胃口不太好也没吃多少，临睡觉还背了一下st表板子就睡了。\n2023/11/18早晨早！心情还不错，但是看了我妈写的家长课堂小作业以后破防了。早餐吃了mai 当劳，急匆匆地出发了。\n到了门口发现学校车还没到，等了一会儿，面了朱老师，去拍合影了。\n不出意外，HBaCr 喊口号还是喊的很大声，有心理准备了就没被吓到。\n进场之前一直在听 HBaCr 絮絮叨叨，ljl 和 jjl 在前面笑，我和 lmh 在讨论 HBaCr 这些顺口溜对其他考生产生的影响。挺放松的，就开考了。\n赛时首先浏览了四道题的输入文件，听见隔壁老哥被字符串吓到倒吸凉气的声音，心里也有一种神秘的感觉。\n开考。\n看了题面，第一印象就是看不太懂，第四题挺好理解，前三道叙述的语言好像都有点繁琐抽象。平静了一下心情决定还是顺序开题。\nA 又读了一遍以后十分钟就秒了。写了个优先队列排序，跑大样例有点卡，换了快读还能接受，就下一题了。\nB 很神秘，越看越复杂，画了很多图，从最短路想到并查集想到连通性啥啥的，发现也弄不懂，放弃了。\nC 也比想的要复杂，也考虑了很久，写了个假贪心，样例也过不了，琢磨得头大。这时还剩两个小时，就也放弃了，去做 D。\nD 根据题面很快就写了个 DP，过程中发现按照自己的思路需要用到 vector 存 “在当前这一天的所有挑战”，但是我不会写 vector 遍历了，采用了一种下下策——二分优化遍历m的过程。调了快一个小时，但是过了预期  的大样例，感觉正解应该是线段树优化 DP，写起来也不值当，就开摆了，回头打暴力。\n剩下一个小时，想去先写 B 的小范围暴力，但是发现性质要更好写一些，就想扣  的性质分， 写了没调出来，有点着急，仔细想了想感觉是想假了，遂怒打  暴力，一遍就过了。平静了一下，去把 C 前两个点的特判部分分写了。写完没测，心态有点崩，还剩下 15min，索性一边检查一边试图捡其他部分分，没查出啥问题，也没拿到别的分。\n于是比赛就结束了。赛时的估分大概是 100+20+10+[36, 56)=[166,186)，还能接受，从出考场心情就淡淡的。\n下午很饿，坐了地铁还有很挤很挤的公交车，背了很重很重的包，去吃了很久很久都没去的黄氏许，然后累的瘫在床上瘫了一晚上，玩了一会儿猫猫、纸牌和扫雷，但是一局都没赢。\n把码交了一份云斗，测出来是 166，不出所料的还能接受，但是看排名形势不是很能一等。\n某个时刻云斗统一测了山东代码，看的时候还没有测完，166还排130左右，高兴了一下就发现排名还在往后退。后来就退到了一个类似于之前S组排名的位置。\n另一个时刻小图灵出的分说我是179，确实很抽象，但是排名跟云斗的也差不多。\n再另一个时刻小图灵改了排名，往前进了二三十名，但是分没变。\n再再另一个时刻上洛谷测了一下，获得了令我震惊的183的高分。\n2023/11/20还是写了一下 vector 遍历，在洛谷跑到了 56pts。云斗没跑过去，依旧是原来的成绩。\n我是小丑。原来 vector 可以用下标遍历。\n无所谓了。\n不知道该怎样结尾可以来收束这曲折但精彩的一年，备考前在机房学习的日子过得艰难但也充满乐趣，让我很难想象没有了oi以后的生活会是什么样子。\n但是，NOIP 2023已经结束了，我们都该向前走了。\n","categories":["游记"],"tags":["EE","缪尔赛思"]}]