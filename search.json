[{"title":"23-9-9-模拟赛题解","url":"/2023/09/13/9-9-mnstj/","content":"gogogobky\nT1. SYOJ #1007 / Luogu P3199\n环形跑【大体思路】二分 + 0/1 分数规划 + Spfa（DFS优化判负环）\n【详解】有一说一，其实不知道 0/1 分数规划是啥也能做。正向考虑找边权平均值最小的环非常困难，所以我们不妨从结果入手反推找有没有符合要求的环。这样二分的思路就明确了，然后就突然想到之前做过一道关于平均值的二分题，这里搬个当时写的题解看看。\n\n我们把环上的每个元素都减去二分出的平均值，在这个基础上跑最短路找环。因为要找的是平均值最小的环，正好与上面这道题相反，如果找到了负环就说明有比二分出的平均值符合要求且存在更优的答案，可以再接着缩小二分范围。\n这里的 Spfa 使用递归写法，求负环比较方便。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 5e3 + 5;const int M = 1e5 + 5;const double inf = 1e9;const double eps = 1e-10;int n, m;int head[N], edge[M], nxt[M], w[M], tot;double l = -inf, r = inf, vis[N], f, dist[N];void add(int x, int y, double z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void check(int x, double d) {    vis[x] = 1;    for (int i = head[x]; i; i = nxt[i]) {        int y = edge[i];        double z = w[i];        if (dist[y] &gt; dist[x] + z - d) {            if (vis[y] || f) {                f = 1;                break;            }            dist[y] = dist[x] + z - d;            check(y, d);        }    }    vis[x] = 0;    return ;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++) {        int a, b;        double c;        scanf(\"%d%d%lf\", &amp;a, &amp;b, &amp;c);        add(a, b, c);    }    while (r - l &gt; eps) {        memset(dist, 0, sizeof(dist));        memset(vis, 0, sizeof(vis));        f = 0;        double mid = (l + r) / 2;        for (int i = 1; i &lt;= n; i++) {            check(i, mid);            if (f) {                break;            }        }        if (f) {            r = mid;        } else {            l = mid;        }    }    if (r == inf) {        printf(\"No solution\");    } else {        printf(\"%.8lf\", l);    }    return 0;}\n\nT2. SYOJ #1019 / Luogu P5764 \n奶牛串门 / 新年好【大体思路】枚举 + 最短路（Dijkstra）\n【详解】我们不知道以一个怎样的顺序可以使走出的距离最短，但是知道一共只有五个点，把这所有的可能性都枚举一遍也只有  种情况，还是很能接受的。\n事实上，在看到这道题的时候第一想法是分层图，把点建五层，从最下面一层开始，每走到一个新的目标点就升一层，最终在第五层统计答案。在写的时候遇到了一个困难，就是可能会在一个环上一直重复走爬层，虽然是走到了足够多的目标点，但是是重复计数的。给目标点原来的编号打标记是不行的，只能硬判断是不是走到了没走过的目标点，以及还需要考虑目标点是可以重复到达的，但是不会计数。略微有亿点点麻烦。感觉这个做法理论上是可以的，但是不知道哪里写挂了，死活调不对，于是遗憾离场。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int inf = 0x3fffffff;const int N = 5e4 + 5;const int M = 1e6 + 10;int n, m, ans = inf, dist[6][N], t[6];int head[N], edge[M], nxt[M], w[M], tot;int b[6] = {1, 2, 3, 4, 5};bool vis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void add(int x, int y, int z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}void dij(int k) {    memset(vis, 0, sizeof(vis));    dist[k][t[k]] = 0;    q.push(make_pair(0, t[k]));    while (!q.empty( )) {        int x = q.top().second;        q.pop();        if (vis[x]) {            continue;        }        vis[x] = 1;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (vis[y]) {                continue;            }            dist[k][y] = min(dist[k][y], dist[k][x] + z);            q.push(make_pair(-dist[k][y], y));        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= 5; i++) {        scanf(\"%d\", &amp;t[i]);    }    t[0] = 1;    for (int i = 1; i &lt;= m; i++) {        int x, y, z;        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);        add(x, y, z);        add(y, x, z);    }    memset(dist, 0x3f, sizeof(dist));    for (int i = 0; i &lt;= 5; i++) {        dij(i);    }    ans = inf;    do {        int res = dist[0][t[b[0]]];        for (int j = 0; j &lt;= 3; j++) {            res += dist[b[j]][t[b[j + 1]]];        }        ans = min(ans, res);    } while (next_permutation(b, b + 5));    printf(\"%d\", ans);    return 0;}\n\nT3. SYOJ #1020 / Luogu P1938 / [USACO09NOV] \n阿龙打工 / Job Hunt S【大体思路】Spfa判负环\n【详解】比赛开始30分钟静坐灵光乍现产物。\n是看到可以无限赚钱的特判联想到了负环的性质，噶的一下就想建个负权边直接跑 Spfa，怒打码一测就发现好像还真有点意思。更有意思的是，当时根本没看见数据范围小小的很可爱适合 Floyd，然后在码里敲了下面这段：\n//啊？咋没记得第一次看的时候数据范围可以跑 Floyd ，所以用了 Spfa\n//等我写个对拍看看\n实际上 Floyd 根本没打。\nSpfa 跑的还是略快一点的。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int N = 5e3 + 5;const int M = 1e5 + 5;int n, m, l, k, s;int head[N], edge[M * 2], nxt[M * 2], tot, cnt[N];bool vis[N],flag;ll w[M * 2], dist[N], ans;void add(int x, int y, ll z) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    head[x] = tot;}priority_queue&lt;pair&lt;int, int&gt; &gt;q;void spfa() {    memset(dist, 0x3f, sizeof(dist));    q.push(make_pair(0, s));    dist[s] = -l;    vis[s] = 1;    while (q.size()) {        int x = q.top().second;        q.pop();        vis[x] = 0;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i];            if (dist[y] &gt; dist[x] + z) {                dist[y] = dist[x] + z;                if (!vis[y]) {                    if (++cnt[y] &gt;= n) {                        printf(\"-1\");                        flag=1;                        exit(0);                    }                    vis[y] = 1;                    q.push(make_pair(-dist[y], y));                }            }        }    }}int main() {    scanf(\"%d%d%d%d%d\", &amp;l, &amp;m, &amp;n, &amp;k, &amp;s);    while (m--) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        add(x, y, -l);    }    while (k--) {        int x, y, z;        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);        add(x, y, z - l);    }    spfa();    for (int i = 1; i &lt;= n; i++) {        ans = min(ans, dist[i]);    }    printf(\"%lld\", -ans);    return 0;}\n\nT4. SYOJ #1030 / Luogu P1266\n奶牛开车 / 速度限制【大体思路】最短路（Dijkstra）\n【详解】这道题特别的就是要用两个量来计算边权，多加一维就能解决。然后就是输出路径，用个  数组就可以实现类似链表的功能，再用个递归向上查倒着输出就好了。\n思路真的不难，细节也是真的很多，调了快一节课。需要仔细处理  为  时的计算方式。\n【代码】#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int inf = 1e9;const int N = 205;const int T = 1005;const int M = 1e5 + 10;int n, m, a, b, c, maxx;int head[N], edge[M * 2], nxt[M * 2], w[M * 2], V[M * 2], tot;double dist[T][T];bool vis[T][T];pair&lt;double, int&gt;pre[T][T];void add(int x, int y, int z, int v) {    edge[++tot] = y;    nxt[tot] = head[x];    w[tot] = z;    V[tot] = v;    head[x] = tot;}priority_queue&lt;pair&lt;double, pair&lt;int, int&gt; &gt; &gt;q;void dijkstra() {    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= 500; j++) {            dist[i][j] = 1e9;        }    }    dist[a][c] = 0;    q.push(make_pair(0, make_pair(a, c)));    while (q.size()) {        int x = q.top().second.first;        int lv = q.top().second.second;        q.pop();        if (vis[x][lv]) {            continue;        }        vis[x][lv] = 1;        for (int i = head[x]; i; i = nxt[i]) {            int y = edge[i], z = w[i], v = V[i];            if (vis[y][v]) {                continue;            }            if (!v) {                v = lv;            }            if (dist[y][v] &gt; dist[x][lv] + 1.0 * z / v) {                dist[y][v] = dist[x][lv] + 1.0 * z / v;                pre[y][v].first = x;                pre[y][v].second = lv;                q.push(make_pair(-dist[y][v], make_pair(y, v)));            }        }    }}void print(int x, int v) {    if (x == a) {        printf(\"%d \", x);        return;    }    print(pre[x][v].first, pre[x][v].second);    printf(\"%d \", x);}int main() {    scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b, &amp;c);    while (m--) {        int x, y, z, v;        scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;z, &amp;v);        add(x, y, z, v);    }    dijkstra();    dist[b][maxx] = inf;    for (int i = 0; i &lt;= 500; i++) {        if (dist[b][i] &lt;= dist[b][maxx]) {            maxx = i;        }    }    print(b, maxx);    return 0;}\n","categories":["博客"],"tags":["EE","史尔特尔"]},{"title":"my-first-blog","url":"/2023/09/13/my-first-blog/","content":"Hi!","tags":["Hi"]},{"title":"Hello World","url":"/2023/09/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n"},{"title":"2023-CSP-S1-游记","url":"/2023/09/22/2023-CSP-S1/","content":"2023 CSP-S1 游记哈，时隔 N 天终于想起来写游记了。\n2023/9/15​        因为是在本校考试，学校周五提前20分钟放学布置考场，于是高高兴兴回了家开摆。之前做模拟题做的都还不错，正式考试之前心情还是非常放松的，故开始疯狂听歌整理文化课材料，略写了一点作业。\n​        特意找了清北哥，祝他明天rp++，也得到了他的进队祝福 buff，感觉这次初赛还没比就圆满了（\n​        超级期待明天的面基，等不及跟朱老师和 myj 贴贴啦！！！\n2023/9/16赛前：​        非常兴奋，早晨多睡了俩小时，起来先写了点whk作业，随便吃了点什么，很快就到下午了。\n​        临走之前摸了几块糖，想着什么时候想起来就吃一块，防止脑袋干烧炸掉。\n​        提前40分钟到了考场，看到了好多小孩，热热闹闹的感觉头都大了。进门路上碰到了某国际部不知道为啥周六还在学校的初中同学，打了个招呼他居然没啥反应，哈。\n​        到的太早没让进楼，在楼下环视一圈就看到了朱老师和 myj，巧巧巧，我直接扑过去主动出击ttt\n​        高兴地聊了一会儿的天，说到在报名名单上看到了远古时代鸭子的同学都没退役，大家都深有同感，莫名其妙的怀念起来了当初考J组的那段黄金时代。又碰见了清北哥，跟他打了招呼，他问我叫啥，是不是 tcw，我爆笑。\n​        找了一会儿 lmh 没找到，这时候就让进考场了，只好先放弃。看着前面的小孩疯狂地奔跑，大喊大叫，不禁感叹年轻真好。\n​        跟 zmq 和 myj 分开以后在考场门口一扭头就看见了 lmh，问了一下没啥事这个时候就可以进场了，我就做了那个第一个进考场的人，好耶！监考的志愿者小美女在我这安检的时候手忙脚乱了一会儿，感觉萌的嘿嘿。\n​        静坐十来分钟，清北哥找我借了支 2B 铅笔，感觉还挺抽象的。闲的没事听右后方同学跟监考老师聊天，然后后面一群人不知道咋就背起来 int 能存储的最大值是多少，听着听着莫名其妙就紧张起来了。\n​        我的位置13号在教室第一排正中间，开考之前在门口看见了游荡的N，打了个招呼，感觉酷酷的。\n赛时：​        开始考试了，一开始感觉脑子一片空白，写着写着题就突然开始播放音乐，好像是 Adele 的 Oh my god，我一整个傻眼。强迫自己冷静了一些，好像状态好一点了，于是接着做题。\n​        前面15个单选乱蒙了一两个，关于 Linux 操作系统的是真不会，开摆。\n​        大概做到阅读程序那几个恶心的模拟，算了很久算错了心态有点崩，第一大题把题绞尽脑汁答的差不多实在受不了了，就跳了几个题去做后面的。磨磨蹭蹭好歹做到完善程序还剩半个多小时，然后连蒙带猜胡乱分析了一遍涂上答题卡就没再看了。\n​        回头算刚才没算出来的大模拟，这次比较顺利，成功做出了选项有的答案，怒选并改了之前理解错误的几个题，这才放下心来。\n​        临交卷十分钟果然进入了自我怀疑环节，很想改点答案，但是忍住了都没改，相信自己的第一直觉。把答题卡上的答案直接抄到答题纸上就开始发呆，这时候才想起来摸个糖吃。\n赛后：​        然后就收卷了。急急跑出去跟 lmh 一起找朱老师，在楼下等散场，我没带手机，lmh 给朱老师发了条消息请求碰头，在这期间遇到了 Petercao 老师、迷茫的 lz、准备离开的 myj、好像在闲逛的 lqz 一伙人，然后没过多久就看到了反向跑过来的朱老师。\n​        往外走，朱老师说到快速幂O(N)的诈骗题，我才突然想起确实是这样，当时做的时候有点小疑问没当回事，反应过来没记忆化时间确实变成O(N)了。。。\n​        溜达出门，发现门口被X组家长围得水泄不通，被创飞了，挤着挤着就发现只剩俺一个力。\n赛后。\n​        去吃了烤鱼，然后就急着估分，我把答案记在准考证上了，先对着洛谷上的答案估了一次，大概 70 来分，一下就放松下来了。没过多久小图灵就出了，把答案输完发现正好是 70 分，然后就盼着看大概排名，饭都没怎么吃好。刷了一会儿有道选择分值改成 2 了，又多了 0.5，于是我喜提 70.5 的初赛成绩。\n","categories":["游记"],"tags":["EE","缪尔赛思"]}]